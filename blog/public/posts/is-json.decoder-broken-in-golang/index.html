<!DOCTYPE html>
<html><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Thoughts on code and building things.">
    
    <link rel="shortcut icon" href="http://localhost:1313/favicon.ico">
    <link href="http://localhost:1313/fontawesome/css/all.min.css" rel="stylesheet">

    <style>
#post-header {
    text-align: center;
}

main#content blockquote {
  margin-top: 10px;
    margin-bottom: 10px;
    margin-left: 50px;
    padding-left: 15px;
    border-left: 5px solid;
    display: inline-flex;
}
main#content p code {
    background: black;
    color: white;
    border-radius: 5px;
}
 
table {
padding: 1.5rem 2.2rem;
    margin: 20px 0;
    margin-left: -3.8%;
    box-sizing: border-box;
    overflow-x: auto;
}

 
table {
  color: #333;
  background: white;
  border: 1px solid grey;
  font-size: 12pt;
  border-collapse: collapse;
}
table thead th,
table tfoot th {
  color: #777;
  background: rgba(0,0,0,.1);
}
table caption {
  padding:.5em;
}
table th,
table td {
  padding: .5em;
  border: 1px solid lightgrey;
}
 
[data-table-theme*=zebra] tbody tr:nth-of-type(odd) {
  background: rgba(0,0,0,.05);
}
[data-table-theme*=zebra][data-table-theme*=dark] tbody tr:nth-of-type(odd) {
  background: rgba(255,255,255,.05);
}
 
[data-table-theme*=dark] {
  color: #ddd;
  background: #333;
  font-size: 12pt;
  border-collapse: collapse;
}
[data-table-theme*=dark] thead th,
[data-table-theme*=dark] tfoot th {
  color: #aaa;
  background: rgba(0255,255,255,.15);
}
[data-table-theme*=dark] caption {
  padding:.5em;
}
[data-table-theme*=dark] th,
[data-table-theme*=dark] td {
  padding: .5em;
  border: 1px solid grey;
}
    </style>

    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Is json.Decoder broken in golang?!</title>
    <script data-goatcounter="https://devtaqkarim.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
    
    
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "50d6391b0ac14e93bae2808292658be2"}'></script>
    
</head>
<body><header id="banner">
    
    <nav>
        <ul>
            <li>
                <a href="https://github.com/mottaquikarim" title="github" target="_blank"><i class='fab fa-github'></i></a>
            </li><li>
                <a href="https://www.linkedin.com/in/mottaqui-karim-5b01212a/" title="linkedin" target="_blank"><i class='fab fa-linkedin'></i></a>
            </li><li>
                <a href="https://twitter.com/taqkarim" title="twitter" target="_blank"><i class='fab fa-twitter'></i></a>
            </li>
        </ul>
    </nav>
    <nav>
        <ul>
            <li>
                <a href="/" title="home">home</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li><li>
                <a href="/tags/" title="tags">tags</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <small><strong>TAGS: </strong></small>
        
        
            <small><strong><a href="http://localhost:1313/tags/golang/">golang</a></strong></small>
        <header id="post-header">
        <h1>Is json.Decoder broken in golang?!</h1><time>January 14, 2021</time></header><aside id="toc">
    <h4>Table of Contents</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#the-issue">The &ldquo;Issue&rdquo;</a></li>
    <li><a href="#grokking-the-json-pkg">Grokking the <code>json</code> pkg</a></li>
    <li><a href="#tracing-bad_json-through-jsondecoder">Tracing <code>bad_json</code> through <code>json.Decoder</code></a>
      <ul>
        <li><a href="#1-jsonnewdecoder-instantiates-a-jsondecoder-struct">1. <code>json.NewDecoder</code> instantiates a <code>json.Decoder</code> struct</a></li>
        <li><a href="#2-decoderdecodev-internally-calls-decoderreadvalue">2. <code>Decoder.Decode(v)</code> internally calls <code>Decoder.readValue()</code></a></li>
        <li><a href="#3-decoderreadvalue-processes-chars-wscannerstep">3. <code>Decoder.readValue</code> processes chars w/<code>scanner.step()</code></a></li>
        <li><a href="#4-stepping-through-decoderreadvalue-with-bad_json">4. Stepping through <code>Decoder.readValue</code> with <code>bad_json</code></a></li>
        <li><a href="#5-bad_json-iteration-table">5. <code>bad_json</code> iteration table</a></li>
        <li><a href="#6-making-sense-of-the-final-iteration-steps">6. Making sense of the final iteration steps</a></li>
      </ul>
    </li>
    <li><a href="#final-remarks">Final Remarks</a></li>
  </ul>
</nav>
</aside>

<p><strong>TL;DR</strong>: No.</p>
<p>Although unintuitive, <strong><code>json.Decoder</code></strong> isn&rsquo;t actually broken! However, some of its behavior can appear <strong>seemingly</strong> wrong when used incorrectly. (Tread carefully.)</p>
<p>In this post, I will dive into the src code of <strong><code>json.Decoder</code></strong> and explore how it works; then I will make sense of these observed &ldquo;incorrect&rdquo; behaviors.</p>
<p>&ndash;</p>
<h2 id="the-issue">The &ldquo;Issue&rdquo;</h2>
<p>Let us start with a simple demonstration of the problem. Consider the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/alecthomas/repr&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reader</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bad_json</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">reader</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fields</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">repr</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://play.golang.org/p/8al6NRe96jw">playground</a>)</p>
<p>This code is fairly straightforward - given some JSON, attempt to decode it into a string map. If decoding fails, print the error.</p>
<p>Take a look at the JSON string more closely:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>
</span></span></code></pre></div><p>This JSON string is clearly malformatted. In particular, the issue is here:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="p">}</span><span class="s">&#34;, &#34;</span><span class="nx">foobaz</span><span class="err">&#34;</span><span class="p">],</span>
</span></span></code></pre></div><p>We have a closing bracket <code>}</code> which shouldn&rsquo;t be followed by anything, but it is!</p>
<p>As such, we would expect any attempt at parsing to fail. And indeed, <strong>json.Unmarshal</strong>-ing this dude expectedly fails:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">bad_json</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://play.golang.org/p/k-v9F9tjglZ">playground</a>)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">invalid character <span class="s1">&#39;&#34;&#39;</span> after top-level value
</span></span></code></pre></div><p><code>&lt;whomp&gt;&lt;/whomp&gt;</code></p>
<p>However, when running this &ldquo;bad&rdquo; json string against the <code>json.NewDecoder().Decode(...)</code> method, it is surprising to see that there is no error!!! Instead, everything after the offensive line is simply ignored!</p>
<p>Here&rsquo;s an excerpt from the codeblock above:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// ... set up code here</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="nx">reader</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bad_json</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">reader</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fields</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// =&gt; We EXPECT this </span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// But instead, we get this! </span>
</span></span><span class="line"><span class="cl"><span class="nx">repr</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fields</span><span class="p">)</span>
</span></span></code></pre></div><p>Executing our code yields the following output:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;hello&#34;</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;foobar&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://play.golang.org/p/8al6NRe96jw">playground</a>)</p>
<p><strong>W.T.F!</strong></p>
<p>Ok, so - this is unexpected!</p>
<p>We would <strong>expect</strong> the <code>err != nil</code> condition to be <strong>true</strong>, forcing the <code>fmt.Println(...)</code> line to run and for <code>fields</code> to be empty.</p>
<p>To find the answer, we&rsquo;ll need to go spelunking into golang&rsquo;s <code>json.Decoder</code> source code and implementation.</p>
<p>(Heads up, <a href="https://ahmet.im/blog/golang-json-decoder-pitfalls/#2-jsondecoder-silently-ignores-invalid-syntax">others</a> have also warned about the behavior we are seeing here. However we will demonstrate by the end of this post that the observed behavior is in fact expected (once we have a better understanding of what it is doing) and not <em>really</em> wrong.)</p>
<p>Alright. Let&rsquo;s do this.</p>
<h2 id="grokking-the-json-pkg">Grokking the <code>json</code> pkg</h2>
<p>Our interest primarily lies in two structs within the <a href="https://golang.org/src/encoding/json/"><code>src/encoding/json</code></a> pkg:</p>
<ul>
<li><a href="https://golang.org/src/encoding/json/stream.go#L14"><code>json.Decoder</code></a></li>
<li><a href="https://golang.org/src/encoding/json/scanner.go#L64"><code>json.scanner</code></a></li>
</ul>
<p>The <code>scanner</code> struct is an internal mechanism used by the <code>Decoder</code> to parse a JSON string. It defines a collection of <code>state transition functions</code> and transition values that manage tracking various phases of parsing the JSON string itself.</p>
<p>For example, consider the following func in <a href="https://golang.org/src/encoding/json/scanner.go#L263"><code>scanner.go#L263</code></a> to better understand how transition functions return transition values.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stateBeginString</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... non relevant code lines</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;&#34;&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateInString</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">scanBeginLiteral</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... non relevant code lines</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This is an example of a &ldquo;state transition function&rdquo;. It marks the beginning of parsing a value in JSON that starts with <code>&quot;</code> character.</p>
<p>Notice here if our input char (<code>c byte</code>) is <code>&quot;</code>, we update our <code>step</code> attribute to the <em>next</em> state transition function, in this case <code>stateInString</code>. Furthermore, we return a new transition value: <code>scanBeginLiteral</code> (indicating that our scanner is currently in the process of interpreting a token literal such as a number or a string in our JSON string).</p>
<p>The transition values are primarily used by code that actually calls the <code>scanner.step</code> transition functions, such as <code>Decoder</code> or <code>decodeState</code>, to understand the current state of parsing by the scanner.</p>
<p>Here&rsquo;s the <a href="https://golang.org/src/encoding/json/scanner.go#L114">full list</a> of transitions values defined and returned by <code>scanner</code> state transition functions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Continue.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanContinue</span>     <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// uninteresting byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanBeginLiteral</span>        <span class="c1">// end implied by next result != scanContinue</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanBeginObject</span>         <span class="c1">// begin object</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanObjectKey</span>           <span class="c1">// just finished object key (string)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanObjectValue</span>         <span class="c1">// just finished non-last object value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanEndObject</span>           <span class="c1">// end object (implies scanObjectValue if possible)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanBeginArray</span>          <span class="c1">// begin array</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanArrayValue</span>          <span class="c1">// just finished array value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanEndArray</span>            <span class="c1">// end array (implies scanArrayValue if possible)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanSkipSpace</span>           <span class="c1">// space byte; can skip; known to be last &#34;continue&#34; result</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Stop.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanEnd</span>   <span class="c1">// top-level value ended *before* this byte; known to be first &#34;stop&#34; result</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanError</span> <span class="c1">// hit an error, scanner.err.</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>The <code>Decoder</code> struct, which is public, manages an instance of scanner as an attribute and tracks the state of JSON parsing (using the transition values such as <code>scanEnd</code> or <code>scanEndArray</code>). The added twist here (and this is significant) is that <code>Decoder</code> loads a <em>portion</em> of the JSON string into a <code>buf</code> attribute and the scanner processes the JSON string in portions, reading chars one at a time from <code>buf</code>.</p>
<p>In addition to tracking the <code>scanner</code>, the <code>Decoder</code> struct also manages an instance of <code>decodeState</code>, which is the mechanism used to actually unmarshal data read from the JSON via the <code>scanner</code>.</p>
<p>For the purposes of our exploration, we will largely ignore the <code>decodeState</code> struct and instead focus primarily on the specifics of <code>scanner</code> and a few methods of the <code>Decoder</code>.</p>
<h2 id="tracing-bad_json-through-jsondecoder">Tracing <code>bad_json</code> through <code>json.Decoder</code></h2>
<p>Hopefully that was a good (but brief) introduction to how the json decoder <em>generally</em> works to parse strings. Let us now apply this understanding to our initial example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>
</span></span></code></pre></div><p>This poorly formatted JSON string is processed with <code>json.Decoder</code> like so (repeating from example on top):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="nx">reader</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">bad_json</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">reader</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fields</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Let&rsquo;s start at <code>json.NewDecoder</code> and given our new (high level) understanding of how the decoding process generally works, attempt to pinpoint exactly why/how the <code>Decode</code> method defies our expectations and does <strong>NOT</strong> raise an err when processing the <code>bad_json</code> string.</p>
<h3 id="1-jsonnewdecoder-instantiates-a-jsondecoder-struct">1. <code>json.NewDecoder</code> instantiates a <code>json.Decoder</code> struct</h3>
<p>To begin, <code>json.NewDecoder</code> creates a new <code>Decoder</code> struct with an <code>r</code> attribute that manages an <code>io.Reader</code> instance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Decoder</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Decoder</span><span class="p">{</span><span class="nx">r</span><span class="p">:</span> <span class="nx">r</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/stream.go#L27">sauce</a>)</p>
<p>From the golang src, here&rsquo;s the full definition of type <code>Decoder</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// A Decoder reads and decodes JSON values from an input stream.</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Decoder</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span>       <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span>     <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span>       <span class="nx">decodeState</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanp</span>   <span class="kt">int</span>   <span class="c1">// start of unread data in buf</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanned</span> <span class="kt">int64</span> <span class="c1">// amount of data already scanned</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scan</span>    <span class="nx">scanner</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>     <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">tokenState</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tokenStack</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/stream.go#L14">sauce</a>)</p>
<p>For the purposes of this analysis, we really only care about the following fields:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Decoder</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scanp</span>   <span class="kt">int</span>   <span class="c1">// start of unread data in buf</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scan</span>    <span class="nx">scanner</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>     <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>scanp</strong></p>
<p>This is an index that we advance from position 0 to the length of our buffer. As we advance this index, we read a single character from the buffer and analyze it via the <code>scanner</code> state machine.</p>
<p><strong>scan</strong></p>
<p>An instance of the internal <code>json.scanner</code> struct. At each value of <code>scanp</code>, we read the character from buffer and pass it into the <code>scanner.step</code> func which processes state transitions such as <code>stateBeginString</code> or <code>stateInString</code> (more on this shortly)</p>
<p><strong>err</strong></p>
<p>We expect <code>err</code> to be NOT <code>nil</code> when we run into malformed JSON. Clearly as it stands from our observations, <code>err</code> <strong>IS</strong> <code>nil</code> which is the problem.</p>
<p>Ok so - now we have an instance of <code>Decoder</code> available to us that knows to read data from our <code>bad_json</code> into an internal buffer. Now, let&rsquo;s look at how the <code>Decoder.Decode(...)</code> method of our <code>Decoder</code> struct commences parsing our JSON data.</p>
<h3 id="2-decoderdecodev-internally-calls-decoderreadvalue">2. <code>Decoder.Decode(v)</code> internally calls <code>Decoder.readValue()</code></h3>
<p>Consider the following snippet from the <code>Decoder.Decode()</code> implementation below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">dec</span> <span class="o">*</span><span class="nx">Decoder</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... non relevant code lines</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Read whole value into buffer.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">readValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... non relevant code lines</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/stream.go#L49">sauce</a>)</p>
<p>We are only focusing on the method call relevant to our current analysis - there are conditionals checked <em>before</em> <code>readValue</code> is executed, which are simply sanity checks for various poorly formatted string states. These conditional checks work as expected so for the purposes of this analysis they are &ldquo;uninteresting&rdquo;.</p>
<p>In short, <code>dec.readValue()</code> uses the <code>dec.scan</code> (which, recall, is an instance of the <code>json.scanner</code> struct) attribute to process chars in the buffer one by one until an error or a <code>scanEnd</code> transition value state is reached. (This is the focus of the next section)</p>
<p>Similarly, assuming <code>dec.readValue()</code> does not generate an error, there is some additional work done by the <code>Decode</code> method (this is the part indicated as &ldquo;non relevant code lines&rdquo; above) that actually relies on the <code>decodeState</code> struct to unmarshal the bytes read and processed by the <code>scanner</code>.</p>
<p>Having looked at <code>Decode</code>, let&rsquo;s now look at the src for <code>readValue</code> to understand how the <code>scanner</code> is used to process data in our JSON string and more importantly, generate errors for invalid JSON.</p>
<h3 id="3-decoderreadvalue-processes-chars-wscannerstep">3. <code>Decoder.readValue</code> processes chars w/<code>scanner.step()</code></h3>
<p>At this point it is clear that whatever the &ldquo;issue&rdquo; is here with the behavior we observe, it must be in <code>readValue</code>. This func is somewhat long so let&rsquo;s only look at the relevant lines:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">dec</span> <span class="o">*</span><span class="nx">Decoder</span><span class="p">)</span> <span class="nf">readValue</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">scanp</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scanp</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="nx">Input</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// help the compiler see that scanp is never negative, so it can remove</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// some bounds checks below.</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">scanp</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Look in the buffer for a new value.</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">;</span> <span class="nx">scanp</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">);</span> <span class="nx">scanp</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">scanp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">bytes</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">scanEnd</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// scanEnd is delayed one byte so we decrement</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// the scanner bytes count by 1 to ensure that</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// this value is correct in the next call of Decode.</span>
</span></span><span class="line"><span class="cl">				<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">bytes</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">scanEndObject</span><span class="p">,</span> <span class="nx">scanEndArray</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// scanEnd is delayed one byte.</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// We might block trying to get that byte from src,</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// so instead invent a space byte.</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">scanEnd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">scanp</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">scanError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">dec</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// ... non relevant code lines</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/stream.go#L89">full sauce</a>)</p>
<p>Upon inspection of this snippet, it is clear that <code>readValue()</code> generates an error if our <code>scanner.step</code> func returns a <code>scanError</code> transition value.</p>
<p>Because we <em>can clearly see</em> that the parsing of our <code>bad_json</code> does <strong>not</strong> raise an error, it must be that the <code>scanEnd</code> or <code>scanEndObject</code>/<code>scanEndArray</code> state is reached before the &ldquo;bad&rdquo; formatting is processed by the <code>scanner</code>.</p>
<p>Still, let&rsquo;s be sure. Let&rsquo;s do one final exercise and run through our <code>bad_json</code> to prove to ourselves that indeed state <code>scanEnd</code> or <code>scanEndObject</code>/<code>scanEndArray</code> is reached before a <code>scanError</code> state can be processed.</p>
<h3 id="4-stepping-through-decoderreadvalue-with-bad_json">4. Stepping through <code>Decoder.readValue</code> with <code>bad_json</code></h3>
<p>For convenience, here is <code>bad_json</code> again:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>
</span></span></code></pre></div><p>Let&rsquo;s start from the beginning. We just instantiated a new <code>Decoder</code> using <code>json.NewDecoder</code>.</p>
<p>When we instantiate a <code>Decoder</code> struct here, we expect the following initial attributes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// which character in the JSON string are we currently considering?</span>
</span></span><span class="line"><span class="cl"><span class="nx">dec</span><span class="p">.</span><span class="nx">scanp</span> <span class="p">=&gt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// initial scanner</span>
</span></span><span class="line"><span class="cl"><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span> <span class="p">=&gt;</span> <span class="nx">scanner</span><span class="p">{}</span>
</span></span></code></pre></div><p>(There are others, but these are the two we care about for now).</p>
<p>We then call <code>Decode</code> to start processing our <code>bad_json</code> string. The first line in <code>readValue</code> is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
</span></span></code></pre></div><p>This method importantly sets our <code>scanner.step</code> state transition function to <code>stateBeginValue</code>.</p>
<p>After some initialization steps, we end up at the big <code>for</code> loop in <code>readValue</code>. To make things easier to grok, let&rsquo;s look at (only) the for loop again:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// Look in the buffer for a new value.</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">;</span> <span class="nx">scanp</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">);</span> <span class="nx">scanp</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">scanp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">bytes</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">scanEnd</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// scanEnd is delayed one byte so we decrement</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// the scanner bytes count by 1 to ensure that</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// this value is correct in the next call of Decode.</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">bytes</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">		<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">scanEndObject</span><span class="p">,</span> <span class="nx">scanEndArray</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// scanEnd is delayed one byte.</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We might block trying to get that byte from src,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// so instead invent a space byte.</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">scanEnd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">scanp</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">scanError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dec</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>scanp</code> here pertains to our <code>dec.scanp</code> attribute which is initially set to <code>0</code> a few lines above. So, our first char is <code>{</code> from <code>bad_json</code>.</p>
<p>We call <code>dec.scan.step</code> and pass in a reference to <code>scanner</code> and <code>c = &quot;{&quot;</code> as args. If the three expected transition states are <em>not</em> returned (<code>scanEnd</code>, <code>scanEndObject</code>, <code>scanEndArray</code>) the loop continues and we advance to the next character (in this case <code>\n</code>).</p>
<h3 id="5-bad_json-iteration-table">5. <code>bad_json</code> iteration table</h3>
<p>To better understand this code as it steps through the chars in <code>bad_json</code>, let&rsquo;s consider a table that describes the &ldquo;state&rdquo; of <code>Decoder</code> and <code>Decoder.scanner</code> as we iterate.</p>
<hr>
<p>Here are the column definitions:</p>
<p><code>row</code></p>
<p>Mainly so that we can look closely at a few rows of this table.</p>
<p><code>ch</code></p>
<p>The current character we are considering within <code>bad_json</code></p>
<p><code>scanp</code></p>
<p>The index corresponding to our current char.</p>
<p><code>step</code></p>
<p>This reflects two key items:</p>
<ul>
<li><strong>now</strong>: the <em>current</em> step saved in the <code>scanner.step</code> attribute</li>
<li><strong>next</strong>: the <em>new</em> step returned after the <strong>state transition func</strong> completed running</li>
<li><strong>ret</strong>: the <strong>transition value</strong> returned by the <strong>state transition func</strong></li>
</ul>
<p><code>step.parseState</code></p>
<p>The <code>scanner</code> also initializes a stack to keep track of opening and closing brackets (for instance, as we parse a JSON string if we encounter a <code>{</code>, we add <code>parseObjectKey</code> (an iota, <a href="https://golang.org/src/encoding/json/scanner.go#L136">sauce</a>) which indicates that we are currently inside <code>{}</code> and have encountered only the left side)</p>
<hr>
<p>To interpret the table below, consider the follow approach:</p>
<p><strong>1</strong>: from <a href="https://golang.org/src/encoding/json/stream.go#L103"><strong>stream.go#L103</strong></a>, determine the state transition function (the transition function corresponds to <strong>now</strong> under the <strong>step</strong> col).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span></code></pre></div><p>In the case of <strong>Row 1</strong>, it would be:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="s">&#34;{&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span></code></pre></div><p><strong>2</strong>: Find the <strong>step</strong> function in <a href="https://golang.org/src/encoding/json/scanner.go#L213"><strong>scanner.go</strong></a>. Walk through it with <code>c = &quot;{&quot;</code> or <code>c = &quot;\n&quot;</code>, etc (whatever is in the <strong>ch</strong> col)</p>
<p>In the case of <strong>Row 1</strong>, our step function would be:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// stateBeginValue is the state at the beginning of the input.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stateBeginValue</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">isSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">scanSkipSpace</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateBeginStringOrEmpty</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">pushParseState</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">parseObjectKey</span><span class="p">,</span> <span class="nx">scanBeginObject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... more cases here, not relevant</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... more logic here, not relevant</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/scanner.go#L213">sauce</a>)</p>
<p><strong>3</strong>: If, in <code>scanner</code> src, <code>pushParseState</code> or <code>popParseState</code> is called within the transition func, expect col <strong>step.parseState</strong> to reflect the value added or removed.</p>
<p>In the case of <strong>Row 1</strong>, <code>pushParseState</code> is called with <code>parseObjectKey</code> so we end up with one item in that array.</p>
<p><strong>4</strong>: Once the <strong>step</strong> function has completed, it should have a return value (the transition value) and a new <strong>step</strong> function (could be same as <strong>now</strong>). Expect col <strong>step</strong>&rsquo;s <strong>ret</strong> to correspond with the returned transition value and <strong>next</strong> to correspond to the <em>new</em> value of <code>scanner.step</code></p>
<p>In the case of <strong>Row 1</strong>, our returned transition value is <code>scanBeginObject</code> and our new step function is <code>stateBeginStringOrEmpty</code>.</p>
<p>Rinse and repeat until <code>scanEnd</code> or <code>scanError</code> is encountered.</p>
<p>(Note that below <code>\s</code> is just shorthand for <code>' '</code>)</p>
<table>
  <thead>
      <tr>
          <th>row</th>
          <th>ch</th>
          <th>scanp</th>
          <th>step</th>
          <th>step.parseState</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>{</td>
          <td>0</td>
          <td><strong>now</strong>: stateBeginValue<br /> <strong>ret</strong>: scanBeginObject<br /> <strong>next</strong>: stateBeginStringOrEmpty</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>2</td>
          <td>\n</td>
          <td>1</td>
          <td><strong>now</strong>: stateBeginStringOrEmpty<br /> <strong>ret</strong>: scanSkipSpace<br /> <strong>next</strong>: stateBeginStringOrEmpty</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>3</td>
          <td>&quot;</td>
          <td>2</td>
          <td><strong>now</strong>: stateBeginStringOrEmpty<br /> <strong>ret</strong>: scanBeginLiteral<br /> <strong>next</strong>: stateInString</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>4</td>
          <td>h</td>
          <td>3</td>
          <td><strong>now</strong>: stateInString<br /> <strong>ret</strong>: scanContinue<br /> <strong>next</strong>: stateInString</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>5</td>
          <td>&hellip;</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>6</td>
          <td>&quot;</td>
          <td>8</td>
          <td><strong>now</strong>: stateInString<br /> <strong>ret</strong>: scanContinue<br /> <strong>next</strong>: stateEndValue</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>7</td>
          <td>:</td>
          <td>9</td>
          <td><strong>now</strong>: stateEndValue<br /> <strong>ret</strong>: scanObjectKey<br /> <strong>next</strong>: stateBeginValue</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>8</td>
          <td>\s</td>
          <td>10</td>
          <td><strong>now</strong> : stateBeginValue <br /> <strong>ret</strong> : scanSkipSpace <br /> <strong>next</strong> : stateBeginValue</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>9</td>
          <td>[</td>
          <td>11</td>
          <td><strong>now</strong> : stateBeginValue <br /> <strong>ret</strong> : scanBeginArray <br /> <strong>next</strong> : stateBeginValueOrEmpty</td>
          <td>parseObjectKey, parseArrayValue</td>
      </tr>
      <tr>
          <td>10</td>
          <td>&quot;</td>
          <td>12</td>
          <td><strong>now</strong> : stateBeginValueOrEmpty <br /> <strong>ret</strong> : scanBeginLiteral <br /> <strong>next</strong> : stateInString</td>
          <td>parseObjectKey, parseArrayValue</td>
      </tr>
      <tr>
          <td>11</td>
          <td>&hellip;</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>12</td>
          <td>]</td>
          <td>20</td>
          <td><strong>now</strong> : stateEndValue <br /> <strong>ret</strong> : scanEndArray <br /> <strong>next</strong> : stateEndValue</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>13</td>
          <td>\s</td>
          <td>-</td>
          <td><strong>now</strong> : stateEndValue <br /> <strong>ret</strong> : scanSkipSpace <br /> <strong>next</strong> : stateEndValue</td>
          <td>parseObjectKey</td>
      </tr>
      <tr>
          <td>14</td>
          <td>}</td>
          <td>21</td>
          <td><strong>now</strong> : stateEndValue <br /> <strong>ret</strong> : scanEndObject <br /> <strong>next</strong> : stateEndValue</td>
          <td></td>
      </tr>
      <tr>
          <td>15</td>
          <td>\s</td>
          <td>-</td>
          <td><strong>now</strong> : stateEndValue <br /> <strong>ret</strong> : scanEnd <br /> <strong>next</strong> : stateEndTop</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="6-making-sense-of-the-final-iteration-steps">6. Making sense of the final iteration steps</h3>
<p>Hopefully, that table is helpful in grokking how the decoding logic works. In particular, let&rsquo;s zoom in on the final 4 rows (12-15).</p>
<p><strong>Row 12 + 13</strong></p>
<p>Let&rsquo;s look at the <code>stateEndValue</code> func:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// stateEndValue is the state after completing a value,</span>
</span></span><span class="line"><span class="cl"><span class="c1">// such as after reading `{}` or `true` or `[&#34;x&#34;`.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... not relevant currently</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ps</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">parseState</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">ps</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... other cases here, not relevant</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">parseArrayValue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateBeginValue</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">scanArrayValue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">popParseState</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">scanEndArray</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;after array element&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://golang.org/src/encoding/json/scanner.go#L277">sauce</a>)</p>
<p>Here&rsquo;s the row:</p>
<table>
  <thead>
      <tr>
          <th>row</th>
          <th>ch</th>
          <th>scanp</th>
          <th>step</th>
          <th>step.parseState</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>12</td>
          <td>]</td>
          <td>20</td>
          <td><strong>now</strong> : stateEndValue <br /> <strong>ret</strong> : scanEndArray <br /> <strong>next</strong> : stateEndValue</td>
          <td>parseObjectKey</td>
      </tr>
  </tbody>
</table>
<p>Because <code>c = &quot;[&quot;</code>, we can see that <code>s.popParseState()</code> is called (which removes <code>parseArrayValue</code> from our <code>parseState</code> stack)</p>
<p>Importantly, we are returned <code>scanEndArray</code>, which - from <code>readValue()</code> - we see requires special handling:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// Look in the buffer for a new value.</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">;</span> <span class="nx">scanp</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">);</span> <span class="nx">scanp</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">scanp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">bytes</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... other cases here, not relevant</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">scanEndObject</span><span class="p">,</span> <span class="nx">scanEndArray</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// scanEnd is delayed one byte.</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We might block trying to get that byte from src,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// so instead invent a space byte.</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">scanEnd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">scanp</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">scanError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dec</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This feels a bit like cheating but essentially, since <code>scanEndArray</code> is returned by our step function, we explicitly call <code>stateEndValue</code> to test and see if we have reached <code>scanEnd</code>.</p>
<p>Let&rsquo;s look at the relevant lines of <code>stateEndValue</code> to understand the logic:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// stateEndValue is the state after completing a value,</span>
</span></span><span class="line"><span class="cl"><span class="c1">// such as after reading `{}` or `true` or `[&#34;x&#34;`.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">scanner</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">parseState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Completed top-level before the current byte.</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateEndTop</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">endTop</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">stateEndTop</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">isSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateEndValue</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">scanSkipSpace</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ignore logic here, not relevant right now</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If our <code>parseState</code> stack were empty, it <em>would</em> return <code>scanEnd</code> which could complete our loop. Otherwise, since we pass in <code>c = ' '</code> here, we &ldquo;short circuit&rdquo; and return the same <code>step</code> transition function.</p>
<p><strong>Row 14 + 15</strong></p>
<p>The final two iterations are very similar to the previous two iterations. The key difference is for the <em>last</em> iteration (row 15), our <code>parseState</code> stack ends up being empty. As such, we actually enter into the <code>n == 0</code> condition:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// excerpt from stateEndValue</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Completed top-level before the current byte.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">step</span> <span class="p">=</span> <span class="nx">stateEndTop</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">endTop</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">stateEndTop</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>and return the coveted <code>scanEnd</code> transition value. In our <code>readValue()</code> func:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="k">switch</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... other cases here, not relevant</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="nx">scanEndObject</span><span class="p">,</span> <span class="nx">scanEndArray</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// scanEnd is delayed one byte.</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// We might block trying to get that byte from src,</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// so instead invent a space byte.</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">stateEndValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dec</span><span class="p">.</span><span class="nx">scan</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">scanEnd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">scanp</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">break</span> <span class="nx">Input</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>the <code>stateEndValue(&amp;dec.scan, ' ') == scanEnd</code> condition is satisfied and we <strong>break</strong> out of our loop.</p>
<blockquote>
<p>In other words, the <code>Decode()</code> method does NOT error because we stop processing our JSON string before the scanner has a change to encounter the malformed portion of our <code>bad_json</code> string!</p></blockquote>
<p>Expounding on this a bit: when that final <code>}</code> is read, <code>Decoder</code> says: &ldquo;ok! I&rsquo;m done. I have a completed scan.&rdquo; For this reason, it <strong>never actually even tries to read the <em>rest</em> of the line</strong> even though there are plenty more characters left to read.</p>
<p>Additionally, note that we <em>could</em> get it to return an error btw, if we call <code>Decode</code> again - since now it will start at <code>&quot;</code> (the first char after <code>}</code>) and it will definitely see and raise an error then.</p>
<p>Furthermore, if we neglected to have the closing <code>}</code> as our first character, <code>Decoder.Decode</code> would actually catch the problem earlier.</p>
<p>Basically, <code>Decode</code> will always respect the closing <code>}</code> because it is expecting to read a <em>stream</em> of data - meaning it <strong>expects</strong> JSON of the form:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">{...}
</span></span><span class="line"><span class="cl">{...}
</span></span><span class="line"><span class="cl">{...}
</span></span></code></pre></div><p>or even:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">{...}{...}{...}
</span></span></code></pre></div><p>Therefore, using <code>Decode</code> to read a single JSON document is not ideal. However it is worth noting that if we really wanted to, we still could use <code>Decode</code> to parse a single doc - we simply must alter how we leverage <code>Decode</code> to fully read out document body.</p>
<p>Personally, the <em>proper</em> way to use <code>Decode</code> really ought to be like so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">readJsonStream</span><span class="p">(</span><span class="nx">jsonStr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fields</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reader</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dec</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ok_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}{&#34;world&#34;: [&#34;some other str&#34;]}`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;++++++++++++++++++ ok json +++++++++++++++++++&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nf">readJsonStream</span><span class="p">(</span><span class="nx">ok_json</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="nx">bad_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;hello&#34;: [&#34;foobar&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">}&#34;, &#34;foobaz&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">  &#34;world&#34;: [&#34;some other str&#34;],
</span></span></span><span class="line"><span class="cl"><span class="s">}`</span>	
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;++++++++++++++++++ bad json +++++++++++++++++++&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nf">readJsonStream</span><span class="p">(</span><span class="nx">bad_json</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">seemingly_bad_but_not_json</span> <span class="o">:=</span> <span class="s">`
</span></span></span><span class="line"><span class="cl"><span class="s">{}{&#34;world&#34;: [&#34;some other str&#34;]}{}{}{}{&#34;hello&#34;: [&#34;foobar&#34;]}`</span>	
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;++++++++++++++++++ not actually bad json +++++++++++++++++++&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nf">readJsonStream</span><span class="p">(</span><span class="nx">seemingly_bad_but_not_json</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(<a href="https://play.golang.org/p/onYb03udRjk">playground</a>)</p>
<p>output:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">++++++++++++++++++ ok json +++++++++++++++++++
</span></span><span class="line"><span class="cl">map[hello:[foobar] world:[some other str]]
</span></span><span class="line"><span class="cl">++++++++++++++++++ bad json +++++++++++++++++++
</span></span><span class="line"><span class="cl">json: cannot unmarshal string into Go value of type map[string][]string
</span></span><span class="line"><span class="cl">map[hello:[foobar]]
</span></span><span class="line"><span class="cl">++++++++++++++++++ not actually bad json +++++++++++++++++++
</span></span><span class="line"><span class="cl">map[hello:[foobar] world:[some other str]]
</span></span></code></pre></div><p>Here, we continously decode in a loop, breaking only when <code>io.EOF</code> is reached or a non-nil error is discovered. In fact, with this refactor, we actually can safely use <code>Decoder</code> to parse any arbitrary JSON strings!</p>
<h2 id="final-remarks">Final Remarks</h2>
<p>In short - <code>json.Decoder</code> is <em>not</em> meant to be a standalone JSON unmarshal-er. Use <code>json.Unmarshal</code> for that. However, for streaming JSON tasks it has a few nice features that are quite useful and assuming your input is indeed streaming json it does not <em>actually</em> silently ignore invalid syntax.</p>
<p>Personally, I would update this <a href="https://golang.org/src/encoding/json/stream.go#L13">comment</a> in the docs:</p>
<blockquote>
<p>A Decoder reads and decodes JSON values from an input stream.</p></blockquote>
<p>to include some more context and background about expected usage of <code>Decode</code>. Based on current documentation, it is not unreasonable to assume <code>Decoder</code> might be used interchangeably with <code>Unmarshal</code> and then become surprised with the unexpected behavior.</p>
<p>But, after all is said and done: <code>json.Decoder</code>&rsquo;s behavior is not actually a bug, if anything it&rsquo;s a feature!</p>

	    <h2>Share</h2>
        <a href="https://twitter.com/intent/tweet?original_referer=http%3a%2f%2flocalhost%3a1313%2fposts%2fis-json.decoder-broken-in-golang%2f?utm_source=twitter&text=Check out this article by @taqkarim: http%3a%2f%2flocalhost%3a1313%2fposts%2fis-json.decoder-broken-in-golang%2f?utm_source=twitter" target="_blank"><i class="fab fa-twitter fa-2x"></i></a>
        <a href="https://www.linkedin.com/shareArticle?mini=false&url=http%3a%2f%2flocalhost%3a1313%2fposts%2fis-json.decoder-broken-in-golang%2f?utm_source=linkedin" target="_blank"><i class="fab fa-linkedin fa-2x"></i></a>
        <a href="https://www.reddit.com/submit?url=http%3A%2F%2Flocalhost%3A1313%2Fposts%2Fis-json.decoder-broken-in-golang%2F%3Futm_source%3Dreddit&title=Is&#43;json.Decoder&#43;broken&#43;in&#43;golang%3F%21" target="_blank" rel="noopener">
          <i class="fab fa-reddit fa-2x"></i>
        </a>
</article>

        </main><footer id="footer">
    Copyright  2022 Taq Karim
</footer>
</body>
</html>
