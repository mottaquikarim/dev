<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on Taq Karim</title>
    <link>https://mottaquikarim.github.io/dev/tags/</link>
    <description>Recent content in Tags on Taq Karim</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://mottaquikarim.github.io/dev/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>You might not be using json.Decoder correctly in golang</title>
      <link>https://mottaquikarim.github.io/dev/posts/you-might-not-be-using-json.decoder-correctly-in-golang/</link>
      <pubDate>Sun, 24 Jan 2021 04:01:51 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/you-might-not-be-using-json.decoder-correctly-in-golang/</guid>
      <description>Table of Contents  TL;DR: prevailing &amp;ldquo;secondary source&amp;rdquo; wisdom (ie: blog posts) about json.Decoder don&amp;rsquo;t demonstrate the proper way to use it.
This post is a follow up to my (kinda lengthy) deep dive into what I thought was a bug in golang&amp;rsquo;s json.Decoder pkg.
Instead, I realized that generally speaking, json.Decoder can be misunderstood - which may lead to unintended consequences. In this post, I will demonstrate a safer pattern that ought to be used instead of the prevailing wisdom.</description>
    </item>
    
    
    
    <item>
      <title>Is json.Decoder broken in golang?!</title>
      <link>https://mottaquikarim.github.io/dev/posts/is-json.decoder-broken-in-golang/</link>
      <pubDate>Thu, 14 Jan 2021 01:26:01 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/is-json.decoder-broken-in-golang/</guid>
      <description>Table of Contents  TL;DR: No.
Although unintuitive, json.Decoder isn&amp;rsquo;t actually broken! However, some of its behavior can appear seemingly wrong when used incorrectly. (Tread carefully.)
In this post, I will dive into the src code of json.Decoder and explore how it works; then I will make sense of these observed &amp;ldquo;incorrect&amp;rdquo; behaviors.
&amp;ndash;
The &amp;ldquo;Issue&amp;rdquo; Let us start with a simple demonstration of the problem. Consider the following:</description>
    </item>
    
    
    
    
    
    <item>
      <title>Using Makefile &#43; Docker for Golang dev</title>
      <link>https://mottaquikarim.github.io/dev/posts/using-makefile-docker-for-golang-dev/</link>
      <pubDate>Fri, 08 Jan 2021 02:29:26 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/using-makefile-docker-for-golang-dev/</guid>
      <description>Table of Contents  (This post was inspired by this article on medium.)
For starters, I&amp;rsquo;d highly recommend reading the article I linked to first. Leo&amp;rsquo;s points about why he chooses Make resonate strongly with me.
In this post, I&amp;rsquo;ll expand slightly on his Makefile and share how make targets can be leveraged with docker for golang development.
(Of course, we can apply this principle to dev with other langs too, but for now let&amp;rsquo;s stick with go).</description>
    </item>
    
    
    
    <item>
      <title>Custom Args in Makefile</title>
      <link>https://mottaquikarim.github.io/dev/posts/custom-args-in-makefile/</link>
      <pubDate>Sun, 03 Jan 2021 00:59:04 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/custom-args-in-makefile/</guid>
      <description>Table of Contents  TL;DR: use $(eval ARGS=${ARGS} [some additional arg]) within a make target to build custom argument sequences for commands wrapped by make targets - like make test
I expound further on the usecase and methodology below üëá
I like to wrap common tasks, such as running unit tests, around a make target.
This way, I can minimize the length of the command I need to run (ie: make test vs go test .</description>
    </item>
    
    
    
    <item>
      <title>Integrating Code Climate w/go pkgs</title>
      <link>https://mottaquikarim.github.io/dev/posts/integrating-code-climate-w/go-pkgs/</link>
      <pubDate>Fri, 01 Jan 2021 14:28:32 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/integrating-code-climate-w/go-pkgs/</guid>
      <description>Table of Contents  TL; DR: When integrating golang code coverage with Code Climate, be sure to set the --prefix arg (set it to your pkg github prefix, ie: &amp;ldquo;github.com/mottaquikarim/esquerydsl&amp;rdquo;) in the after-build stage in order for your src code to be recognized by the test reporter.
If ^^ that didn&amp;rsquo;t make sense, read on below for the full background üëç
I&amp;rsquo;ve recently published a golang pkg, called esquerydsl, which facillitates safe construction of elasticsearch queries in golang.</description>
    </item>
    
    
    
    <item>
      <title>Generate Lambda Layer Artifacts w/Docker</title>
      <link>https://mottaquikarim.github.io/dev/posts/generate-lambda-layer-artifacts-w/docker/</link>
      <pubDate>Tue, 22 Dec 2020 16:41:25 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/generate-lambda-layer-artifacts-w/docker/</guid>
      <description>Table of Contents  This post (and accompanying code) was inspired by this tutorial and a need to easily generate lambda layer artifacts for a grad course I teach at Baruch University.
Github
TL;DR: Generate a lambda layer artifact for python using this:
‚ûú cat &amp;gt;&amp;gt; requirements.txt requests==2.24.0 ‚ûú docker run -v $PWD:/data mottaquikarim/pkglambdalayer:latest On completion, expect the following:
‚ûú ls -ahl total 1792 drwxr-xr-x 5 tkarim staff 160B Dec 21 08:36 .</description>
    </item>
    
    
    
    <item>
      <title>Safely Construct Elasticsearch Queries w/Golang</title>
      <link>https://mottaquikarim.github.io/dev/posts/safely-construct-elasticsearch-queries-w/golang/</link>
      <pubDate>Wed, 16 Dec 2020 14:28:28 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/safely-construct-elasticsearch-queries-w/golang/</guid>
      <description>Table of Contents  TL; DR: ya boy wrote a golang elasticsearch query dsl utility. Find it here!
The Why If you&amp;rsquo;ve used elasticsearch with golang, then you&amp;rsquo;ve probably used the official elasticsearch go client.
The es go client is exhaustive and generally, pretty great. However, it can be a bit&amp;hellip;scary when having to deal with constructing search queries using the elasticsearch query dsl
Take for instance the following (from here in the docs):</description>
    </item>
    
    
    
    <item>
      <title>Gotcha w/comparing base64 encoded strs</title>
      <link>https://mottaquikarim.github.io/dev/posts/gotcha-w/comparing-base64-encoded-strs/</link>
      <pubDate>Sun, 13 Dec 2020 09:29:57 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/gotcha-w/comparing-base64-encoded-strs/</guid>
      <description>Table of Contents  Here&amp;rsquo;s a fun experiment - consider two &amp;ldquo;numerical&amp;rdquo; strings such as:
a = &amp;#34;1004&amp;#34; b = &amp;#34;1053&amp;#34; Is a &amp;lt; b? Why yes, of course it is!
Ok, let&amp;rsquo;s try this again, this time b64encoding our two strings.
import base64 a_b64 = base64.b64encode(a.encode(&amp;#34;utf8&amp;#34;)).decode(&amp;#34;utf8&amp;#34;) # MTAwNA== b_b64 = base64.b64encode(b.encode(&amp;#34;utf8&amp;#34;)).decode(&amp;#34;utf8&amp;#34;) # MTA1Mw== How about now?
Is a_b64 &amp;lt; b_b64? NOPE.
What gives?!
And more importantly, this observation implies that:</description>
    </item>
    
    
    
    <item>
      <title>Connecting to Elasticsearch Configured via Docker</title>
      <link>https://mottaquikarim.github.io/dev/posts/connecting-to-elasticsearch-configured-via-docker/</link>
      <pubDate>Mon, 16 Mar 2020 06:37:08 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/connecting-to-elasticsearch-configured-via-docker/</guid>
      <description>Table of Contents  Elastic Search and Docker Setting up an elasticsearch + kibana runtime is very easy to do with docker-compose:
version:&amp;#39;3&amp;#39;services:elasticsearch:image:docker.elastic.co/elasticsearch/elasticsearch:6.3.2environment:-cluster.name=docker-cluster-bootstrap.memory_lock=true-&amp;#34;ES_JAVA_OPTS=-Xms512m -Xmx512m&amp;#34;ulimits:memlock:soft:-1hard:-1ports:-&amp;#34;9200:9200&amp;#34;kibana:image:docker.elastic.co/kibana/kibana:6.3.2ports:-&amp;#34;5601:5601&amp;#34; For more information on the defaults (ulimits or environment variables, please see this post)
To run, you simply:
docker-compose up -d And then navigate over to http://localhost:9200 for elasticsearch or http://localhost:5601 for kibana.
Gotchas As with all things, there may be some gotchas associated with this setup.</description>
    </item>
    
    
    
    <item>
      <title>Self Grading Quizzes With Airtable</title>
      <link>https://mottaquikarim.github.io/dev/posts/self-grading-quizzes-with-airtable/</link>
      <pubDate>Mon, 16 Mar 2020 06:31:03 +0000</pubDate>
      
      <guid>https://mottaquikarim.github.io/dev/posts/self-grading-quizzes-with-airtable/</guid>
      <description>Table of Contents  This semester, I am teaching a course at Baruch University on Big Data Technologies.
I resolved to administer a small quiz at the start of class to get a feel for how the class is doing overall in terms of comprehension of key materials.
However, grading quizzes - especially at such a recurring cadence - will definitely be time consuming, even for a small class of say 15 people (my class has 47 students).</description>
    </item>
    
    
  </channel>
</rss>
